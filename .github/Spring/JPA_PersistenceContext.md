# JPA 영속성 컨텍스트 (Persistence Context)

## 1. JPA와 엔티티(Entity) 소개

### JPA란?
JPA(Java Persistence API)는 자바 진영의 ORM(Object-Relational Mapping) 표준 기술이다. JPA를 사용하면 개발자가 SQL 쿼리를 직접 작성하는 대신, 자바 객체를 통해 데이터베이스를 조작할 수 있다. 이를 통해 객체 지향적인 코드를 유지하면서 데이터베이스 작업을 수행할 수 있다.

### 엔티티(Entity)란?
**엔티티는 데이터베이스의 테이블과 매핑되는 자바 객체.**

-> 즉, 데이터베이스에 저장하고 관리할 대상이 되는 데이터를 자바 객체로 표현한 것.

엔티티의 주요 특징:
- `@Entity` 어노테이션으로 정의
- 반드시 기본 키(`@Id`)를 가져야 함
- 테이블의 각 컬럼은 엔티티 클래스의 필드(또는 프로퍼티)와 매핑됨
- 기본 생성자(no-arg constructor)가 필요함
- 상속, 연관관계 등 객체 지향적 모델링 가능

```java
@Entity
public class Member {
    @Id
    private Long id;
    
    private String name;
    private int age;
    
    // 기본 생성자
    public Member() {}
    
    // Getter, Setter 메서드
    // ...
}
```

이 Member 엔티티는 데이터베이스의 MEMBER 테이블(기본값)과 매핑되며, id, name, age 필드는 테이블의 각 컬럼과 매핑된다.

## 2. ❓ 궁금증에서 시작하기
> "나는 UPDATE 쿼리를 쓰지 않았는데, 데이터가 바뀌어 있었다!"

JPA를 쓰다 보면 흔히 마주치는 상황! :

```java
@Transactional
public void updateUser(Long id) {
    User user = em.find(User.class, id); // DB 쿼리 1번 (SELECT)
    user.setName("Jane");               // UPDATE 없음
}
```

👉 그런데 트랜잭션이 끝나면 **UPDATE 쿼리가 자동으로 실행됨** → 이유는?
## 3. 영속성 컨텍스트란?

### 영속성 컨텍스트 개념
- 영속성 컨텍스트(Persistence Context)는 JPA가 엔티티를 관리하는 가상의 환경 또는 메모리 공간. 
- '엔티티를 영구 저장하는 환경'이라는 의미를 가지고 있지만, 실제로는 데이터베이스에 바로 저장하는 것이 아니라 애플리케이션과 데이터베이스 사이에서 엔티티를 관리하는 중간 계층의 역할을 한다.

영속성 컨텍스트는 눈에 보이지 않는 **논리적인 개념**으로, **EntityManager를 통해 접근하고 조작**할 수 있다. 
하나의 EntityManager가 생성될 때 하나의 영속성 컨텍스트가 생성되고, EntityManager를 통해 엔티티를 저장하거나 조회하면 EntityManager는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

-> 📝 쉽게 말해: "JPA가 기억하고 있는 객체 저장소"

### 영속성 컨텍스트와 EntityManager
-**EntityManager는 엔티티를 저장, 수정, 삭제, 조회** 등 엔티티와 관련된 모든 일을 처리하는 관리자. 
- 개발자는 EntityManager를 통해 영속성 컨텍스트에 접근.
- EntityManager를 생성하면 그 안에 영속성 컨텍스트 있음

>> EntityManagerFactory통해 요청이 올 때 마다 EntityManager 생성
>>>EntityManager는 내부적으로 Connection 사용하여 DB 접근

- entity 저장: EntityManager.persist(entity)

* 데이터를 영속성 컨텍스트에 저장
* 엔티티를 영속화한다는 의미
* DB에 저장하는 것 아님!
* spring에서 EntityManager 여러 개, 영속성 컨텍스트 1개 존재

-> 엔티티 매니저:영속성 컨텍스트 = N : 1

- 스프링 프레임워크와 함께 사용할 경우, 스프링이 EntityManager를 만들고 관리하며 트랜잭션 범위의 영속성 컨텍스트를 제공. 
- 이는 트랜잭션이 시작될 때 영속성 컨텍스트가 생성되고, 트랜잭션이 종료될 때 영속성 컨텍스트가 소멸되는 방식.



### 영속성 컨텍스트의 내부 구조
- 영속성 컨텍스트는 내부적으로 1차 캐시, 쓰기 지연 SQL 저장소 등의 구조를 가지고 있습다.
- 이러한 구조를 통해 성능 최적화와 데이터 일관성을 보장함.

```
┌─────────────────────────────────────────────┐
│            애플리케이션                      │
│  ┌─────────────────────────────────────┐    │
│  │       영속성 컨텍스트               │    │
│  │  ┌─────────┐  ┌─────────┐           │    │
│  │  │ Entity1 │  │ Entity2 │           │    │
│  │  └─────────┘  └─────────┘           │    │
│  │                                     │    │
│  │  ┌─────────┐  ┌───────────────────┐ │    │
│  │  │ Entity3 │  │ 쓰기 지연 SQL 저장소│ │    │
│  │  └─────────┘  └───────────────────┘ │    │
│  └───────────────────────────────────────────┘    │
│                                              │
│  ┌─────────────────┐   ┌─────────────────┐   │
│  │  EntityManager  │───┤     Query       │   │
│  └─────────────────┘   └─────────────────┘   │
└─────────────────────────────────────────────────┘
           │                   │
           ▼                   ▼
┌─────────────────────────────────────────────┐
│               데이터베이스                   │
└─────────────────────────────────────────────┘
```
## 4. 영속성 컨텍스트의 특징

### 1차 캐시
- 영속성 컨텍스트는 내부에 1차 캐시라는 저장소를 가지고 있음.
- 엔티티를 조회하면 먼저 이 1차 캐시에서 엔티티를 찾고, 없으면 데이터베이스에서 조회.
- 이렇게 조회한 엔티티는 1차 캐시에 저장되므로, 이후에 같은 엔티티를 조회하면 데이터베이스를 거치지 않고 메모리에서 바로 가져올 수 있어 성능상 이점이 있음.

1차 캐시는 Map 형태로 구현되어 있으며, 키는 @Id로 매핑한 식별자이고, 값은 엔티티 인스턴스이다.

```
┌─────────────────────────────────────────┐
│           영속성 컨텍스트               │
│     (1차 캐시)                          │
│  ┌─────────────────────────────────┐    │
│  │  @Id     │      Entity Object   │    │
│  ├─────────────────────────────────┤    │
│  │    1     │      User{id=1}      │    │
│  │    2     │      User{id=2}      │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
```

### 쓰기 지연(Write-Behind)
EntityManager는 트랜잭션을 커밋하기 전까지 데이터베이스에 엔티티를 저장하지 않고, 내부 쿼리 저장소에 SQL을 모아둡니다. 이를 '쓰기 지연'이라고 합니다. 트랜잭션을 커밋하는 시점에 모아둔 SQL을 데이터베이스에 한 번에 보내는 방식으로 작동합니다.

이 방식은 여러 개의 INSERT SQL을 모아서 한 번에 데이터베이스에 보낼 수 있어 네트워크 비용을 줄일 수 있습니다.

```
// 쓰기 지연 과정
1. em.persist(memberA);  // SQL 생성 및 저장소에 보관
2. em.persist(memberB);  // SQL 생성 및 저장소에 보관
3. // 여기까지 SQL을 데이터베이스에 보내지 않음
4. transaction.commit(); // SQL을 데이터베이스에 보냄
```

### 변경 감지(Dirty Checking)
JPA는 트랜잭션이 커밋되는 시점에 영속성 컨텍스트에 있는 모든 엔티티의 변경 사항을 자동으로 감지합니다. 이를 '변경 감지'라고 합니다.

변경 감지는 다음과 같은 방식으로 작동합니다:
1. 트랜잭션이 시작되고 엔티티를 영속성 컨텍스트에 보관할 때, 해당 엔티티의 최초 상태를 스냅샷으로 저장
2. 트랜잭션이 커밋될 때, 현재 엔티티 상태와 스냅샷을 비교
3. 변경된 엔티티가 있으면 자동으로 UPDATE SQL 생성 및 실행

이 기능 덕분에 개발자는 엔티티의 값만 변경하면 되고, 별도로 UPDATE SQL을 작성하거나 호출하지 않아도 됩니다.

### 지연 로딩(Lazy Loading)
JPA는 연관된 엔티티를 실제로 사용하는 시점에 데이터베이스에서 조회하는 지연 로딩 기능을 제공합니다. 이 기능은 불필요한 데이터 로딩을 방지하여 애플리케이션의 성능을 향상시킵니다.

예를 들어, 회원과 주문의 관계에서 회원을 조회할 때 주문 정보가 당장 필요하지 않다면, 주문 정보는 실제로 사용할 때까지 로딩을 지연시킬 수 있습니다.

```java
@Entity
public class Member {
    @Id
    private Long id;
    
    private String name;
    
    @OneToMany(mappedBy = "member", fetch = FetchType.LAZY) // 지연 로딩 설정
    private List<Order> orders;
    
    // ...
}
```

---
