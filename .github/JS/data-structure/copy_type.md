### 1. **원시 타입과 참조 타입**
자바스크립트의 데이터 타입은 크게 **원시 타입(Primitive Type)** 과 **참조 타입(Reference Type)** 으로 나늼.

#### **1) 원시 타입 (Primitive Type)**
- **값 자체를 저장**하며, 변수에 값을 할당하면 **새로운 메모리 공간에 독립적인 값이 저장**됩니다.
- 변경 시 기존 값이 수정되는 것이 아니라 **새로운 메모리 공간에 새로운 값이 저장**됩니다.
- **데이터 종류**: `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`
- **복사 방식**: **값 자체를 복사(깊은 복사)**

📌 **예제**:
```js
let a = '원본 데이터';
let b = a;  // 값 자체를 복사 (깊은 복사)

a = '수정 데이터';

console.log(a); // '수정 데이터'
console.log(b); // '원본 데이터' (영향을 받지 않음)
```
> `b`는 `a`와 독립적인 값이므로 `a`가 변경되더라도 `b`는 그대로 유지됩니다.

---

#### **2) 참조 타입 (Reference Type)**
- 객체(Object), 배열(Array), 함수(Function) 등 **비원시 타입**은 **메모리 주소(참조값, reference)를 저장**합니다.
- 새로운 변수에 할당할 경우 **값이 아닌 메모리 주소가 복사**됩니다. 즉, 같은 메모리를 참조하게 됩니다.
- **복사 방식**: **주소(참조값)를 복사(얕은 복사)**

📌 **예제**:
```js
let obj1 = { name: '원본 데이터' };
let obj2 = obj1;  // 메모리 주소(참조값)만 복사 (얕은 복사)

obj1.name = '수정 데이터';

console.log(obj1); // { name: '수정 데이터' }
console.log(obj2); // { name: '수정 데이터' }  (같은 메모리를 공유하기 때문)
```
> `obj2`도 같은 메모리를 바라보기 때문에 `obj1`을 변경하면 `obj2`도 영향을 받습니다.

---

### 2. **얕은 복사(Shallow Copy) vs. 깊은 복사(Deep Copy)**

#### **1) 얕은 복사(Shallow Copy)**
- **객체의 1차원적인 값들만 복사**하고, 내부에 중첩된 객체(객체 속의 객체)는 **참조값을 복사**합니다.
- 즉, **최상위 속성들은 독립적으로 복사되지만, 중첩 객체들은 원본 객체와 같은 메모리를 공유**합니다.
- 변경이 일어나면 원본 객체와 복사된 객체 **모두에 영향을 줌**.

📌 **얕은 복사 예제**
```js
const obj1 = {
  a: 1,
  b: { c: 2 }
};

// slice()를 이용한 얕은 복사
const obj2 = Object.assign({}, obj1);

// 복사된 객체의 중첩된 속성 변경
obj2.b.c = 3;

console.log(obj1.b.c); // 3 (원본도 변경됨)
console.log(obj2.b.c); // 3 (같은 메모리를 참조 중)
```
> `b` 객체는 메모리 주소만 복사되었기 때문에 `obj2.b.c`를 변경하면 `obj1.b.c`도 변경됩니다.

##### ✅ **얕은 복사 방법**
1. **Array.prototype.slice()**
2. **Object.assign()**
3. **Spread 연산자 `{ ...obj }`**  
   → 모두 1차원적인 값만 복사하고 중첩 객체는 참조값을 복사하는 얕은 복사 방식입니다.

---

#### **2) 깊은 복사(Deep Copy)**
- **원본 객체와 완전히 독립적인 새로운 객체를 생성**합니다.
- 내부에 중첩된 객체까지 **모두 새로운 메모리 공간에 저장**되므로 **원본과 복사본이 완전히 분리**됩니다.

📌 **깊은 복사 예제**
```js
const obj1 = {
  a: 1,
  b: { c: 2 }
};

// JSON 방식으로 깊은 복사
const obj2 = JSON.parse(JSON.stringify(obj1));

obj2.b.c = 3;

console.log(obj1.b.c); // 2 (원본은 영향 없음)
console.log(obj2.b.c); // 3 (독립적인 객체)
```
> `JSON.stringify()`로 문자열로 변환한 뒤, 다시 `JSON.parse()`로 객체로 변환하면 **새로운 객체가 생성**되어 참조가 끊어집니다.

##### ✅ **깊은 복사 방법**
1. **JSON.parse(JSON.stringify(obj))**  
   - 객체 내 `function`, `Symbol`, `undefined` 속성은 제거됨.
2. **커스텀 재귀 함수를 이용한 깊은 복사**
3. **Lodash 라이브러리의 `cloneDeep()` 함수 활용**  
   - `npm install lodash` 후 사용 가능.

📌 **Lodash 활용 예제**
```js
const _ = require("lodash");

const obj1 = { a: 1, b: { c: 2 } };
const obj2 = _.cloneDeep(obj1);

obj2.b.c = 3;

console.log(obj1.b.c); // 2 (원본은 영향 없음)
console.log(obj2.b.c); // 3 (독립적인 객체)
```

---

### 3. **얕은 복사 vs. 깊은 복사의 차이점 요약**
| 구분  | 얕은 복사 (Shallow Copy) | 깊은 복사 (Deep Copy) |
|-------|----------------|----------------|
| 복사 범위 | 1차원 속성만 복사, 중첩 객체는 참조 | 객체 전체를 새로운 메모리 공간에 복사 |
| 참조 여부 | 중첩 객체는 참조값 복사 (같은 객체 공유) | 모든 객체가 독립적인 메모리를 가짐 |
| 원본 변경 영향 | 복사본의 중첩 속성 변경 시 원본도 변경됨 | 원본과 완전히 독립적 |
| 대표 방법 | `Object.assign()`, `{ ...obj }`, `.slice()` | `JSON.parse(JSON.stringify(obj))`, Lodash `cloneDeep()`, 커스텀 재귀 함수 |

---

### 4. **정리**
- **원시 타입(Primitive Type)** 은 값 자체를 저장하고 **깊은 복사**가 기본 동작.
- **참조 타입(Reference Type)** 은 메모리 주소(참조값)를 저장하며, 기본적으로 **얕은 복사**가 발생.
- **얕은 복사(Shallow Copy)** 는 객체의 1차원 속성만 복사하고 중첩 객체는 참조값을 공유하여 **원본이 변경되면 복사본도 영향을 받음**.
- **깊은 복사(Deep Copy)** 는 중첩 객체까지 **새로운 메모리 공간에 복사하여 독립적인 객체를 생성**.
- `Object.assign()`, `{ ...obj }` 등은 **얕은 복사**를 수행하며, **깊은 복사**를 위해선 `JSON.parse(JSON.stringify(obj))`, `lodash.cloneDeep()`, 재귀 함수 등이 필요.

🔹 **언제 깊은 복사가 필요한가?**
- 원본 데이터를 변경하지 않고 안전하게 복사해야 할 때.
- 불변성(immutability)이 중요한 경우 (e.g. Redux 상태 관리).
- 원본 객체가 복잡한 중첩 구조를 가지고 있는 경우.
